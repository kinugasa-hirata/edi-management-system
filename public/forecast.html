<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDI Management System - Forecast</title>
    
    <!-- External CSS -->
    <link rel="stylesheet" href="/css/dashboard-styles.css">
    <style>
        /* Enhanced forecast-specific styles */
        .forecast-table {
            width: 100%;
            overflow-x: auto;
            margin-bottom: 30px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-radius: 12px;
        }

        .forecast-table table {
            min-width: 900px;
            font-size: 0.9rem;
            border-collapse: collapse;
            background: white;
        }

        .forecast-table th {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            text-align: center;
            padding: 15px 10px;
            font-weight: 600;
            white-space: nowrap;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .forecast-table th.drawing-header {
            background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
            position: sticky;
            left: 0;
            z-index: 110;
            min-width: 150px;
            border-right: 2px solid white;
        }

        .forecast-table th.product-header {
            background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
            position: sticky;
            left: 150px;
            z-index: 110;
            min-width: 130px;
            border-right: 2px solid white;
        }

        .forecast-table td.drawing-cell {
            background: #f8fafc;
            position: sticky;
            left: 0;
            z-index: 50;
            font-weight: 700;
            font-size: 0.8rem;
            padding: 12px 10px;
            border-right: 2px solid #e5e7eb;
            min-width: 150px;
            border-bottom: 1px solid #e5e7eb;
        }

        .forecast-table td.product-cell {
            background: #f1f5f9;
            position: sticky;
            left: 150px;
            z-index: 50;
            font-size: 0.85rem;
            padding: 12px 10px;
            border-right: 2px solid #e5e7eb;
            min-width: 130px;
            border-bottom: 1px solid #e5e7eb;
        }

        .forecast-table td {
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
            text-align: center;
        }

        .forecast-table tr:hover td:not(.drawing-cell):not(.product-cell) {
            background: #f0f4ff;
        }

        .forecast-input {
            width: 100%;
            padding: 8px 10px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            text-align: center;
            font-size: 0.95rem;
            background: white;
            min-width: 90px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .forecast-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
            background: #fefefe;
        }

        .forecast-input:disabled {
            background: #f3f4f6;
            color: #6b7280;
            cursor: not-allowed;
        }

        .forecast-input.changed {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .month-header {
            text-align: center;
            font-size: 0.9rem;
            line-height: 1.3;
            min-width: 100px;
            padding: 12px 8px;
        }

        .month-japanese {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 3px;
            color: white;
        }

        .month-english {
            font-size: 0.75rem;
            opacity: 0.9;
            color: rgba(255, 255, 255, 0.8);
        }

        .forecast-controls {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            background: #f8fafc;
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .import-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 10px 15px;
            background: white;
        }

        .btn {
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn:disabled {
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
            background: #9ca3af !important;
            border-color: #9ca3af !important;
            color: white !important;
        }

        .btn-primary {
            background: #4f46e5;
            border-color: #4338ca;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #4338ca;
        }

        .btn-secondary {
            background: #6b7280;
            border-color: #4b5563;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #4b5563;
        }

        .btn-success {
            background: #059669;
            border-color: #047857;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #047857;
        }

        .btn-info {
            background: #0ea5e9;
            border: 1px solid #0284c7;
            color: white;
        }

        .btn-info:hover:not(:disabled) {
            background: #0284c7;
        }

        .btn-warning {
            background: #f59e0b;
            border: 1px solid #d97706;
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            background: #d97706;
        }

        .btn-danger {
            background: #dc2626;
            border: 1px solid #b91c1c;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #b91c1c;
        }

        .btn-logout {
            background: #dc2626;
            border-color: #b91c1c;
            color: white;
        }

        .btn-logout:hover:not(:disabled) {
            background: #b91c1c;
        }

        .import-notice {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border: 1px solid #f59e0b;
            border-radius: 10px;
            padding: 20px 25px;
            margin-bottom: 25px;
            font-size: 0.95rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .import-notice h4 {
            margin: 0 0 12px 0;
            color: #92400e;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .import-notice ul {
            margin: 10px 0 0 25px;
            color: #92400e;
        }

        .import-notice li {
            margin-bottom: 5px;
        }

        .import-notice p {
            margin: 8px 0;
            color: #92400e;
        }

        .forecast-summary {
            background: linear-gradient(135deg, #f8fafc 0%, #e5e7eb 100%);
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .summary-item {
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
        }

        .summary-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .summary-number {
            font-size: 1.8rem;
            font-weight: 700;
            color: #4f46e5;
            margin-bottom: 8px;
        }

        .summary-label {
            color: #6b7280;
            font-size: 0.95rem;
            font-weight: 500;
        }

        .navigation-bar {
            background: #f8fafc;
            padding: 15px 30px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 25px;
            border-radius: 8px;
        }

        .nav-link {
            color: #6b7280;
            text-decoration: none;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .nav-link.active {
            background: #4f46e5;
            color: white;
        }

        .save-status {
            margin-left: auto;
            font-size: 0.9rem;
            color: #6b7280;
            font-weight: 500;
        }

        .save-status.saving {
            color: #f59e0b;
        }

        .save-status.saved {
            color: #059669;
        }

        .save-status.error {
            color: #dc2626;
        }

        .admin-only.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .read-only-notice {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 12px 16px;
            color: #92400e;
            font-size: 0.95rem;
            font-weight: 500;
            display: none;
        }

        .read-only-notice.show {
            display: block;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 30px;
            color: #6b7280;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .message {
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .message.success {
            background: #d1fae5;
            border: 1px solid #10b981;
            color: #065f46;
        }

        .message.error {
            background: #fee2e2;
            border: 1px solid #ef4444;
            color: #991b1b;
        }

        .message.info {
            background: #dbeafe;
            border: 1px solid #3b82f6;
            color: #1e40af;
        }

        .message.warning {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            color: #92400e;
        }

        .data-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .record-count {
            background: #4f46e5;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6b7280;
        }

        .empty-state .icon {
            font-size: 3rem;
            margin-bottom: 20px;
        }

        .empty-state h3 {
            color: #374151;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .forecast-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }
            
            .import-controls {
                justify-content: center;
            }

            .navigation-bar {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
                padding: 15px;
            }

            .nav-link {
                text-align: center;
            }

            .save-status {
                margin-left: 0;
                text-align: center;
            }

            .forecast-table th, .forecast-table td {
                padding: 6px 4px;
                font-size: 0.8rem;
            }

            .forecast-input {
                padding: 6px 8px;
                font-size: 0.85rem;
                min-width: 70px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="user-info" id="userInfo">
                <span id="userDisplay">Loading...</span>
            </div>
            <h1>üìà EDI Forecast Management</h1>
            <p>Monthly Production Forecast Planning with Dashboard Integration</p>
        </div>

        <!-- Navigation Bar -->
        <div class="navigation-bar">
            <a href="/dashboard" class="nav-link">üìä Dashboard</a>
            <a href="/forecast" class="nav-link active">üìà Forecast</a>
            <a href="/stock" class="nav-link">üì¶ Material Stock</a>
            <div class="save-status" id="saveStatus">Ready</div>
            <button class="btn btn-logout" onclick="logout()">üö™ Logout</button>
        </div>

        <div class="content">
            <div id="messageContainer"></div>
            <div class="loading" id="loadingIndicator">
                <div class="spinner"></div>
                Loading forecast data...
            </div>

            <!-- Forecast Summary -->
            <div class="forecast-summary">
                <h3 style="margin-bottom: 20px; color: #1f2937; font-size: 1.3rem;">üìä Forecast Summary</h3>
                <div class="summary-grid">
                    <div class="summary-item">
                        <div class="summary-number" id="totalForecast">0</div>
                        <div class="summary-label">Total Forecast</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-number" id="nextMonthTotal">0</div>
                        <div class="summary-label">Next Month</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-number" id="changedCells">0</div>
                        <div class="summary-label">Unsaved Changes</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-number" id="lastSaved">-</div>
                        <div class="summary-label">Last Saved</div>
                    </div>
                </div>
            </div>

            <!-- Excel Import Format Notice -->
            <div class="import-notice">
                <h4>üìã Excel Import Format Guide</h4>
                <p>Your Excel file should have this structure:</p>
                <ul>
                    <li><strong>Column A:</strong> Drawing Number (PP4166-4681P003, etc.)</li>
                    <li><strong>Column B:</strong> Product Name (optional)</li>
                    <li><strong>Columns C+:</strong> Month headers (8Êúà, 9Êúà, 2025/8, Aug, etc.)</li>
                    <li><strong>Data rows:</strong> Quantity values for each month</li>
                </ul>
                <p>The system will automatically detect month columns and convert them to the correct format for dashboard integration.</p>
            </div>

            <!-- Forecast Controls -->
            <div class="forecast-controls">
                <!-- Save controls -->
                <button class="btn btn-primary admin-only" id="saveAllBtn" onclick="saveAllForecasts()">
                    üíæ Save All Changes
                </button>
                
                <!-- Excel Import Controls -->
                <div class="import-controls admin-only">
                    <input type="file" id="forecastFileInput" accept=".xlsx,.xls" style="display: none;">
                    <button class="btn btn-info" id="chooseForecastFileBtn" onclick="chooseForecastFile()">
                        üìÅ Choose Excel File
                    </button>
                    <button class="btn btn-warning" id="importForecastBtn" onclick="importForecastExcel()" disabled>
                        üì§ Import Forecast Data
                    </button>
                </div>
                
                <!-- Management controls -->
                <button class="btn btn-danger admin-only" id="clearAllBtn" onclick="clearAllForecastsFromDatabase()">
                    üóëÔ∏è Clear All Data
                </button>
                <button class="btn btn-success" id="refreshBtn" onclick="refreshForecastData()">
                    üîÑ Refresh Data
                </button>
                <button class="btn btn-secondary" id="debugBtn" onclick="showDebugInfo()">
                    üîç Debug Info
                </button>
                
                <div class="read-only-notice" id="readOnlyNotice">
                    üëÅÔ∏è View-Only Mode - Contact admin for edit access
                </div>
            </div>

            <!-- Forecast Table -->
            <div class="data-header">
                <h2>Monthly Production Forecast</h2>
                <span class="record-count" id="recordCount">Loading...</span>
            </div>

            <div class="forecast-table" id="forecastTableContainer">
                <div class="empty-state">
                    <div class="icon">üìà</div>
                    <h3>Loading Forecast Data</h3>
                    <p>Please wait while we load the forecast information...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhanced JavaScript -->
    <script>
        class ForecastManager {
            constructor() {
                this.currentUser = null;
                this.userPermissions = { canEdit: false, canView: true };
                this.forecastData = {};
                this.changedCells = new Set();
                this.months = [];
                this.products = [
                    { drawing: 'PP4166-4681P003', name: 'ÔΩ±ÔΩØÔæäÔæüÔæåÔæûÔæöÔΩ∞Ôæë' },
                    { drawing: 'PP4166-4681P004', name: 'ÔΩ±ÔΩØÔæäÔæüÔæåÔæûÔæöÔΩ∞Ôæë' },
                    { drawing: 'PP4166-4726P003', name: 'ÔæÑÔΩØÔæåÔæüÔæåÔæüÔæöÔΩ∞ÔæÑ' },
                    { drawing: 'PP4166-4726P004', name: 'ÔæÑÔΩØÔæåÔæüÔæåÔæüÔæöÔΩ∞ÔæÑ' },
                    { drawing: 'PP4166-4731P002', name: 'ÔæêÔæÑÔæûÔæôÔæåÔæöÔΩ∞Ôæë' },
                    { drawing: 'PP4166-7106P001', name: 'ÔæêÔæÑÔæûÔæôÔæåÔæöÔΩ∞Ôæë' },
                    { drawing: 'PP4166-7106P003', name: 'ÔæêÔæÑÔæûÔæôÔæåÔæöÔΩ∞Ôæë' }
                ];
            }

            // Enhanced - Generate 12 months starting from current month with consistent formatting
            generateMonths() {
                const months = [];
                const now = new Date();
                
                for (let i = 0; i < 12; i++) {
                    const date = new Date(now.getFullYear(), now.getMonth() + i, 1);
                    const year = date.getFullYear();
                    const month = date.getMonth() + 1;
                    
                    // Ensure consistent MM/01 format
                    const monthKey = `${String(month).padStart(2, '0')}/01`;
                    
                    // Japanese month names
                    const japaneseMonths = ['1Êúà', '2Êúà', '3Êúà', '4Êúà', '5Êúà', '6Êúà', 
                                          '7Êúà', '8Êúà', '9Êúà', '10Êúà', '11Êúà', '12Êúà'];
                    
                    // English month names
                    const englishMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                         'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    
                    months.push({
                        key: monthKey,
                        display: japaneseMonths[month - 1],
                        english: englishMonths[month - 1],
                        year: year,
                        month: month,
                        fullDate: `${year}/${String(month).padStart(2, '0')}/01`
                    });
                    
                    console.log(`üìÖ Generated month ${i + 1}: key="${monthKey}", display="${japaneseMonths[month - 1]}"`);
                }
                
                this.months = months;
                console.log('üìÖ Total months generated:', months.length);
                return months;
            }

            // Load user authentication
            async loadUserInfo() {
                try {
                    const response = await fetch('/api/user-info');
                    if (response.ok) {
                        const userInfo = await response.json();
                        this.currentUser = userInfo;
                        this.userPermissions = userInfo.permissions;
                        
                        this.updateUIForPermissions();
                        this.updateUserDisplay(userInfo);
                        
                        return userInfo;
                    } else {
                        console.log('‚ùå User not authenticated, redirecting to login');
                        window.location.href = '/';
                        return null;
                    }
                } catch (error) {
                    console.error('Error loading user info:', error);
                    this.showMessage('Failed to load user information', 'error');
                    return null;
                }
            }

            updateUserDisplay(userInfo) {
                const userDisplay = document.getElementById('userDisplay');
                if (userDisplay) {
                    const roleClass = userInfo.role === 'admin' ? 'admin' : 'user';
                    const roleText = userInfo.role === 'admin' ? 'ADMIN' : 'VIEW ONLY';
                    userDisplay.innerHTML = `
                        ${userInfo.username}
                        <span class="user-role ${roleClass}">${roleText}</span>
                    `;
                }
            }

            updateUIForPermissions() {
                const adminElements = document.querySelectorAll('.admin-only');
                const readOnlyNotice = document.getElementById('readOnlyNotice');

                if (!this.userPermissions.canEdit) {
                    adminElements.forEach(element => {
                        element.classList.add('disabled');
                        if (element.tagName === 'BUTTON') {
                            element.disabled = true;
                        }
                    });
                    
                    if (readOnlyNotice) readOnlyNotice.classList.add('show');
                } else {
                    adminElements.forEach(element => {
                        element.classList.remove('disabled');
                        if (element.tagName === 'BUTTON') {
                            element.disabled = false;
                        }
                    });
                    
                    if (readOnlyNotice) readOnlyNotice.classList.remove('show');
                }
            }

            // Enhanced - Load forecast data with proper type conversion
            async loadForecastData() {
                try {
                    this.showLoading(true);
                    
                    const response = await fetch('/api/forecasts');
                    
                    if (response.status === 401) {
                        this.showMessage('Session expired. Please log in again.', 'error');
                        setTimeout(() => window.location.href = '/', 2000);
                        return;
                    }
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const forecasts = await response.json();
                    console.log('üìä Raw forecast data from API:', forecasts);
                    console.log('üìä Forecast data count:', forecasts.length);
                    
                    // Enhanced: Convert array to object with proper type conversion
                    this.forecastData = {};
                    forecasts.forEach((forecast, index) => {
                        const key = `${forecast.drawing_number}-${forecast.month_date}`;
                        // CRITICAL: Ensure quantity is a number
                        const quantity = parseInt(forecast.quantity) || 0;
                        this.forecastData[key] = quantity;
                        console.log(`‚úÖ Loaded forecast ${index + 1}: ${key} = ${quantity} (type: ${typeof quantity})`);
                    });
                    
                    console.log('üìä Processed forecast data object keys:', Object.keys(this.forecastData));
                    console.log('üìä Total forecast entries loaded:', Object.keys(this.forecastData).length);
                    console.log('üìä Complete forecast data object:', this.forecastData);
                    
                    this.renderForecastTable();
                    this.updateSummary();
                    this.clearChangedCells();
                    
                    // IMMEDIATE VERIFICATION after load
                    setTimeout(() => {
                        this.debugTableState();
                    }, 500);
                    
                } catch (error) {
                    this.showMessage('Failed to load forecast data: ' + error.message, 'error');
                    console.error('Error loading forecast data:', error);
                } finally {
                    this.showLoading(false);
                }
            }

            // Enhanced - Render forecast table with better debugging
            renderForecastTable() {
                const container = document.getElementById('forecastTableContainer');
                const recordCount = document.getElementById('recordCount');
                
                this.generateMonths();
                
                if (recordCount) {
                    recordCount.textContent = `${this.products.length} products √ó ${this.months.length} months`;
                }

                console.log('üé® Rendering forecast table...');
                console.log('üìÖ Generated months:', this.months);
                console.log('üìä Current forecast data keys:', Object.keys(this.forecastData));
                console.log('üìä Current forecast data:', this.forecastData);

                // DEBUG: Check for any forecast data
                const hasAnyData = Object.keys(this.forecastData).length > 0;
                console.log('üìä Has any forecast data:', hasAnyData);

                const tableHTML = `
                    <table>
                        <thead>
                            <tr>
                                <th class="drawing-header">ÂìÅÁï™<br><small>Drawing Number</small></th>
                                <th class="product-header">ÂìÅÂêç<br><small>Product Name</small></th>
                                ${this.months.map(month => `
                                    <th class="month-header">
                                        <div class="month-japanese">${month.display}</div>
                                        <div class="month-english">${month.english} ${month.year}</div>
                                    </th>
                                `).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${this.products.map(product => `
                                <tr>
                                    <td class="drawing-cell"><strong>${product.drawing}</strong></td>
                                    <td class="product-cell">${product.name}</td>
                                    ${this.months.map(month => {
                                        const key = `${product.drawing}-${month.key}`;
                                        const value = this.forecastData[key] || 0;
                                        
                                        // ENHANCED DEBUG LOGGING
                                        if (this.forecastData[key]) {
                                            console.log(`üîç Cell Debug:`);
                                            console.log(`   Product: ${product.drawing}`);
                                            console.log(`   Month: ${month.key} (${month.display})`);
                                            console.log(`   Key: ${key}`);
                                            console.log(`   Stored Value: ${this.forecastData[key]}`);
                                            console.log(`   Display Value: ${value}`);
                                            console.log(`   Value Type: ${typeof value}`);
                                        }
                                        
                                        return `
                                            <td>
                                                <input type="number" 
                                                       class="forecast-input" 
                                                       value="${value > 0 ? value : ''}"
                                                       data-drawing="${product.drawing}"
                                                       data-month="${month.key}"
                                                       data-key="${key}"
                                                       placeholder="0"
                                                       min="0"
                                                       ${!this.userPermissions.canEdit ? 'disabled' : ''}
                                                       onchange="forecastManager.onCellChange(this)"
                                                       onblur="forecastManager.onCellBlur(this)">
                                            </td>
                                        `;
                                    }).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;

                container.innerHTML = tableHTML;
                console.log('‚úÖ Forecast table rendered');
                
                // IMMEDIATE VERIFICATION: Check if any input has values
                setTimeout(() => {
                    const inputs = document.querySelectorAll('.forecast-input');
                    let filledInputs = 0;
                    inputs.forEach(input => {
                        if (input.value && input.value !== '0' && input.value !== '') {
                            filledInputs++;
                            console.log(`‚úÖ Found filled input: ${input.dataset.key} = ${input.value}`);
                        }
                    });
                    console.log(`üìä Total filled inputs after render: ${filledInputs} / ${inputs.length}`);
                    
                    if (filledInputs === 0 && Object.keys(this.forecastData).length > 0) {
                        console.log('‚ùå ERROR: Have forecast data but no inputs are filled!');
                        console.log('üìä Forecast data keys:', Object.keys(this.forecastData));
                        console.log('üìä Month keys generated:', this.months.map(m => m.key));
                    }
                }, 100);
            }

            // Handle cell value changes
            onCellChange(input) {
                const key = input.dataset.key;
                const value = parseInt(input.value) || 0;
                
                // Mark as changed
                input.classList.add('changed');
                this.changedCells.add(key);
                
                // Update local data
                this.forecastData[key] = value;
                
                this.updateSummary();
                this.updateSaveStatus('unsaved', 'Unsaved changes');
            }

            onCellBlur(input) {
                // Auto-save individual cell if user has permission and auto-save is enabled
                if (this.userPermissions.canEdit) {
                    // Optional: implement auto-save for individual cells
                }
            }

            // Enhanced - Save all forecast changes with proper key parsing
            async saveAllForecasts() {
                if (!this.userPermissions.canEdit) {
                    this.showMessage('You do not have permission to save changes', 'error');
                    return;
                }

                if (this.changedCells.size === 0) {
                    this.showMessage('No changes to save', 'warning');
                    return;
                }

                try {
                    this.updateSaveStatus('saving', 'Saving...');
                    this.showLoading(true);
                    
                    const forecasts = [];
                    this.changedCells.forEach(key => {
                        console.log(`üíæ Processing changed cell: ${key}`);
                        
                        // FIXED: Proper parsing using lastIndexOf to handle multiple dashes
                        const lastDashIndex = key.lastIndexOf('-');
                        
                        if (lastDashIndex === -1) {
                            console.error(`‚ùå Invalid key format: ${key}`);
                            return;
                        }
                        
                        const drawingNumber = key.substring(0, lastDashIndex);    // "PP4166-4681P003"
                        const monthDate = key.substring(lastDashIndex + 1);       // "08/01"
                        
                        console.log(`üíæ Parsed key "${key}":`);
                        console.log(`   Drawing: "${drawingNumber}"`);
                        console.log(`   Month: "${monthDate}"`);
                        console.log(`   Quantity: ${this.forecastData[key]}`);
                        
                        // Use correct field names that match backend expectation
                        forecasts.push({
                            drawing_number: drawingNumber,   // Match backend field name
                            month_date: monthDate,           // Match backend field name
                            quantity: this.forecastData[key] || 0
                        });
                    });

                    console.log('üíæ Forecast data to save:', forecasts);

                    const response = await fetch('/api/forecasts/batch', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ forecasts })
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.showMessage(`Saved ${result.saved} forecast entries successfully`, 'success');
                        this.clearChangedCells();
                        this.updateSaveStatus('saved', 'All changes saved');
                        this.updateSummary();
                        
                        // Notify other windows about the update
                        this.notifyOtherWindows('FORECAST_UPDATED');
                        
                        // IMMEDIATE DEBUG: Check what was actually saved
                        console.log('üîç DEBUG: Immediately after save success:');
                        console.log('üìä Current forecastData:', this.forecastData);
                        
                        // Force refresh from server to verify
                        setTimeout(async () => {
                            console.log('üîÑ Verifying save by reloading from server...');
                            await this.loadForecastData();
                        }, 1000);
                    } else {
                        this.showMessage(result.error || 'Failed to save forecasts', 'error');
                        this.updateSaveStatus('error', 'Save failed');
                    }
                } catch (error) {
                    this.showMessage('Failed to save forecasts: ' + error.message, 'error');
                    this.updateSaveStatus('error', 'Save failed');
                } finally {
                    this.showLoading(false);
                }
            }

            // Clear all forecast data from database
            async clearAllForecastsFromDatabase() {
                if (!this.userPermissions.canEdit) {
                    this.showMessage('You do not have permission to clear data', 'error');
                    return;
                }

                if (!confirm('‚ö†Ô∏è DANGER: This will permanently delete ALL forecast data from the database.\n\nThis action cannot be undone. Are you sure you want to continue?')) {
                    return;
                }

                try {
                    this.showLoading(true);
                    this.showMessage('Clearing all forecast data from database...', 'warning');
                    
                    const response = await fetch('/api/forecasts/clear', {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.showMessage('All forecast data cleared successfully from database', 'success');
                        
                        // Clear local data
                        this.forecastData = {};
                        this.clearChangedCells();
                        
                        // Re-render table with empty data
                        this.renderForecastTable();
                        this.updateSummary();
                        this.updateSaveStatus('saved', 'Data cleared');
                        
                        // Notify other windows about the update
                        this.notifyOtherWindows('FORECAST_UPDATED');
                        
                    } else {
                        this.showMessage(result.error || 'Failed to clear forecast data', 'error');
                    }
                } catch (error) {
                    this.showMessage('Failed to clear forecast data: ' + error.message, 'error');
                } finally {
                    this.showLoading(false);
                }
            }

            // Refresh forecast data (reload from server)
            async refreshForecastData() {
                try {
                    this.showMessage('Refreshing forecast data...', 'info');
                    await this.loadForecastData();
                    this.showMessage('Forecast data refreshed successfully', 'success');
                } catch (error) {
                    this.showMessage('Failed to refresh forecast data: ' + error.message, 'error');
                }
            }

            // Clear changed cells tracking
            clearChangedCells() {
                this.changedCells.clear();
                
                // Remove changed styling from inputs
                const inputs = document.querySelectorAll('.forecast-input.changed');
                inputs.forEach(input => {
                    input.classList.remove('changed');
                });
            }

            // Update summary statistics
            updateSummary() {
                const totalForecast = Object.values(this.forecastData).reduce((sum, val) => sum + (val || 0), 0);
                
                // Calculate next month total
                const nextMonth = this.months[1]; // Next month after current
                let nextMonthTotal = 0;
                if (nextMonth) {
                    this.products.forEach(product => {
                        const key = `${product.drawing}-${nextMonth.key}`;
                        nextMonthTotal += this.forecastData[key] || 0;
                    });
                }

                // Update UI
                document.getElementById('totalForecast').textContent = totalForecast.toLocaleString();
                document.getElementById('nextMonthTotal').textContent = nextMonthTotal.toLocaleString();
                document.getElementById('changedCells').textContent = this.changedCells.size;
                
                // Update last saved time
                if (this.changedCells.size === 0) {
                    const now = new Date();
                    document.getElementById('lastSaved').textContent = now.toLocaleTimeString();
                }
            }

            // Update save status
            updateSaveStatus(status, message) {
                const saveStatus = document.getElementById('saveStatus');
                if (saveStatus) {
                    saveStatus.textContent = message;
                    saveStatus.className = 'save-status ' + status;
                }
            }

            // Cross-window communication
            notifyOtherWindows(messageType) {
                try {
                    // Use localStorage to communicate with other tabs/windows
                    const message = {
                        type: messageType,
                        timestamp: Date.now(),
                        source: 'forecast-manager'
                    };
                    localStorage.setItem('crossWindowMessage', JSON.stringify(message));
                    
                    // Clean up immediately
                    setTimeout(() => {
                        localStorage.removeItem('crossWindowMessage');
                    }, 1000);
                    
                } catch (error) {
                    console.warn('Could not send cross-window message:', error);
                }
            }

            // Utility methods
            showLoading(show) {
                const loading = document.getElementById('loadingIndicator');
                if (loading) {
                    loading.style.display = show ? 'block' : 'none';
                }
            }

            showMessage(message, type) {
                const container = document.getElementById('messageContainer');
                if (!container) return;

                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                messageDiv.textContent = message;
                
                container.appendChild(messageDiv);
                
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.parentNode.removeChild(messageDiv);
                    }
                }, 5000);
            }

            async logout() {
                try {
                    await fetch('/api/logout', { method: 'POST' });
                    window.location.href = '/';
                } catch (error) {
                    console.error('Logout error:', error);
                    window.location.href = '/';
                }
            }

            // Enhanced Debug function to check data consistency
            async showDebugInfo() {
                try {
                    const response = await fetch('/api/debug/forecasts');
                    if (response.ok) {
                        const debugData = await response.json();
                        console.log('üîç DEBUG: Raw database data:', debugData);
                        
                        alert(`Debug Info:
üìä Data source: ${debugData.source}
üìä Total records: ${debugData.count}
üìä Sample data: ${JSON.stringify(debugData.data.slice(0, 3), null, 2)}

üìä Local forecast data keys: ${Object.keys(this.forecastData).length}
üìä Generated months: ${this.months.length}

Check console for detailed logs.`);
                    } else {
                        alert('Failed to fetch debug info');
                    }
                } catch (error) {
                    console.error('Debug error:', error);
                    alert('Debug error: ' + error.message);
                }
            }

            // Enhanced Debug helper function - Table state verification
            debugTableState() {
                console.log('üîç TABLE STATE DEBUG:');
                console.log('üìä Forecast data object:', this.forecastData);
                console.log('üìä Generated months:', this.months);
                
                // Check each product-month combination
                this.products.forEach(product => {
                    console.log(`\nüîç Product: ${product.drawing}`);
                    this.months.forEach((month, index) => {
                        const key = `${product.drawing}-${month.key}`;
                        const storedValue = this.forecastData[key];
                        const inputElement = document.querySelector(`[data-key="${key}"]`);
                        const inputValue = inputElement ? inputElement.value : 'NOT_FOUND';
                        
                        if (storedValue || inputValue) {
                            console.log(`   Month ${index + 1} (${month.key}):`);
                            console.log(`     Key: ${key}`);
                            console.log(`     Stored: ${storedValue} (${typeof storedValue})`);
                            console.log(`     Input: ${inputValue}`);
                            console.log(`     Element exists: ${!!inputElement}`);
                        }
                    });
                });
                
                // Summary
                const totalStoredEntries = Object.keys(this.forecastData).length;
                const filledInputs = document.querySelectorAll('.forecast-input').length;
                const nonEmptyInputs = Array.from(document.querySelectorAll('.forecast-input')).filter(input => input.value && input.value !== '0').length;
                
                console.log(`\nüìä SUMMARY:`);
                console.log(`   Stored entries: ${totalStoredEntries}`);
                console.log(`   Total inputs: ${filledInputs}`);
                console.log(`   Non-empty inputs: ${nonEmptyInputs}`);
            }

            // Initialize the forecast manager
            async initialize() {
                try {
                    console.log('üöÄ Initializing Enhanced Forecast Manager...');
                    
                    await this.loadUserInfo();
                    await this.loadForecastData();
                    
                    // Listen for cross-window messages
                    window.addEventListener('storage', (event) => {
                        if (event.key === 'crossWindowMessage' && event.newValue) {
                            try {
                                const message = JSON.parse(event.newValue);
                                if (message.type === 'EDI_UPDATED' || message.type === 'STOCK_UPDATED') {
                                    console.log('üì° Received cross-window update notification');
                                    // Optionally refresh data
                                }
                            } catch (error) {
                                console.warn('Could not parse cross-window message:', error);
                            }
                        }
                    });
                    
                    // Auto-refresh every 5 minutes
                    setInterval(() => {
                        if (this.changedCells.size === 0) {
                            this.loadForecastData();
                        }
                    }, 300000);
                    
                    console.log('‚úÖ Enhanced Forecast Manager initialized successfully');
                } catch (error) {
                    console.error('‚ùå Failed to initialize forecast manager:', error);
                    this.showMessage('Failed to initialize forecast manager', 'error');
                }
            }
        }

        // Create global instance
        const forecastManager = new ForecastManager();

        // Handle forecast file selection
        function chooseForecastFile() {
            const fileInput = document.getElementById('forecastFileInput');
            if (fileInput) {
                fileInput.click();
            }
        }

        // Enhanced Import forecast data from Excel with better error handling
        async function importForecastExcel() {
            if (!forecastManager.userPermissions.canEdit) {
                forecastManager.showMessage('You do not have permission to import data', 'error');
                return;
            }

            const fileInput = document.getElementById('forecastFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                forecastManager.showMessage('Please select an Excel file first', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('forecastFile', file);

            try {
                forecastManager.showLoading(true);
                forecastManager.showMessage('Importing forecast data from Excel...', 'info');
                
                const response = await fetch('/api/import-forecast', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    forecastManager.showMessage(result.message, 'success');
                    
                    // Show import details
                    if (result.details) {
                        console.log('üìä Import details:', result.details);
                        const detailsMsg = `Import completed: ${result.details.saved} forecasts saved from ${result.details.rowsProcessed} rows`;
                        forecastManager.showMessage(detailsMsg, 'info');
                    }
                    
                    // Reload forecast data
                    await forecastManager.loadForecastData();
                    
                    // Notify other windows
                    forecastManager.notifyOtherWindows('FORECAST_UPDATED');
                    
                    // Reset file input
                    fileInput.value = '';
                    const importBtn = document.getElementById('importForecastBtn');
                    if (importBtn) {
                        importBtn.disabled = true;
                        importBtn.textContent = 'üì§ Import Forecast Data';
                    }
                } else {
                    forecastManager.showMessage(result.error || 'Import failed', 'error');
                    if (result.details) {
                        console.error('‚ùå Import error details:', result.details);
                    }
                }
            } catch (error) {
                if (error.message.includes('403')) {
                    forecastManager.showMessage('You do not have permission to import data', 'error');
                } else {
                    forecastManager.showMessage('Import failed: ' + error.message, 'error');
                }
                console.error('‚ùå Import error:', error);
            } finally {
                forecastManager.showLoading(false);
            }
        }

        // Global functions
        function saveAllForecasts() {
            forecastManager.saveAllForecasts();
        }

        function clearAllForecastsFromDatabase() {
            forecastManager.clearAllForecastsFromDatabase();
        }

        function refreshForecastData() {
            forecastManager.refreshForecastData();
        }

        function logout() {
            forecastManager.logout();
        }

        function showDebugInfo() {
            forecastManager.showDebugInfo();
        }

        // Enhanced Debug testing functions
        window.testForecastDebug = function() {
            forecastManager.debugForecastData();
        };

        window.testSessionDebug = async function() {
            try {
                const response = await fetch('/api/user-info');
                const data = await response.json();
                console.log('üîç Session debug - User info:', data);
                return data;
            } catch (error) {
                console.log('‚ùå Session debug failed:', error);
                return null;
            }
        };

        window.testForecastTableState = function() {
            if (forecastManager) {
                forecastManager.debugTableState();
            } else {
                console.log('‚ùå Forecast manager not found');
            }
        };

        window.testForceRefresh = async function() {
            if (forecastManager) {
                console.log('üîÑ Forcing forecast data refresh...');
                await forecastManager.loadForecastData();
                console.log('‚úÖ Refresh complete');
            } else {
                console.log('‚ùå Forecast manager not found');
            }
        };

        // Add file input change handler
        document.addEventListener('DOMContentLoaded', function() {
            forecastManager.initialize();
            
            const forecastFileInput = document.getElementById('forecastFileInput');
            const importForecastBtn = document.getElementById('importForecastBtn');
            
            if (forecastFileInput && importForecastBtn) {
                forecastFileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    
                    if (file && forecastManager.userPermissions.canEdit) {
                        importForecastBtn.disabled = false;
                        importForecastBtn.textContent = `üì§ Import ${file.name}`;
                        forecastManager.showMessage(`Excel file selected: ${file.name}`, 'success');
                    } else {
                        importForecastBtn.disabled = true;
                        importForecastBtn.textContent = 'üì§ Import Forecast Data';
                    }
                });
            }
        });
    </script>
</body>
</html>