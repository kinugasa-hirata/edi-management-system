<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDI Management System - Forecast</title>
    
    <!-- External CSS -->
    <link rel="stylesheet" href="/css/dashboard-styles.css">
    <style>
        /* Additional forecast-specific styles */
        .forecast-table {
            width: 100%;
            overflow-x: auto;
            margin-bottom: 30px;
        }

        .forecast-table table {
            min-width: 900px;
            font-size: 0.9rem;
        }

        .forecast-table th {
            background: #4f46e5;
            color: white;
            text-align: center;
            padding: 12px 8px;
            font-weight: 600;
            white-space: nowrap;
        }

        .forecast-table th.drawing-header {
            background: #1f2937;
            position: sticky;
            left: 0;
            z-index: 10;
            min-width: 140px;
        }

        .forecast-table th.product-header {
            background: #374151;
            position: sticky;
            left: 140px;
            z-index: 10;
            min-width: 120px;
        }

        .forecast-table td.drawing-cell {
            background: #f8fafc;
            position: sticky;
            left: 0;
            z-index: 5;
            font-weight: 600;
            font-size: 0.8rem;
            padding: 8px;
            border-right: 2px solid #e5e7eb;
            min-width: 140px;
        }

        .forecast-table td.product-cell {
            background: #f1f5f9;
            position: sticky;
            left: 140px;
            z-index: 5;
            font-size: 0.8rem;
            padding: 8px;
            border-right: 2px solid #e5e7eb;
            min-width: 120px;
        }

        .forecast-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            text-align: center;
            font-size: 0.9rem;
            background: white;
            min-width: 80px;
        }

        .forecast-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.1);
        }

        .forecast-input:disabled {
            background: #f3f4f6;
            color: #6b7280;
            cursor: not-allowed;
        }

        .forecast-input.changed {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .month-header {
            text-align: center;
            font-size: 0.9rem;
            line-height: 1.2;
            min-width: 90px;
        }

        .month-japanese {
            font-size: 1rem;
            font-weight: 700;
            margin-bottom: 2px;
        }

        .month-english {
            font-size: 0.7rem;
            opacity: 0.8;
        }

        .forecast-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .import-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px 12px;
            background: #f8fafc;
        }

        .btn-info {
            background: #0ea5e9;
            border: 1px solid #0284c7;
            color: white;
            font-size: 0.9rem;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-info:hover {
            background: #0284c7;
            transform: translateY(-1px);
        }

        .btn-info:disabled {
            background: #9ca3af;
            border-color: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .btn-warning {
            background: #f59e0b;
            border: 1px solid #d97706;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-warning:hover {
            background: #d97706;
            transform: translateY(-1px);
        }

        .btn-warning:disabled {
            background: #9ca3af;
            border-color: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .import-notice {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 6px;
            padding: 12px 16px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .import-notice h4 {
            margin: 0 0 8px 0;
            color: #92400e;
            font-size: 1rem;
        }

        .import-notice ul {
            margin: 8px 0 0 20px;
            color: #92400e;
        }

        .import-notice p {
            margin: 4px 0;
            color: #92400e;
        }

        .forecast-summary {
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .summary-item {
            text-align: center;
        }

        .summary-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: #4f46e5;
            margin-bottom: 5px;
        }

        .summary-label {
            color: #6b7280;
            font-size: 0.9rem;
        }

        .navigation-bar {
            background: #f8fafc;
            padding: 15px 30px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .nav-link {
            color: #6b7280;
            text-decoration: none;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .nav-link.active {
            background: #4f46e5;
            color: white;
        }

        .save-status {
            margin-left: auto;
            font-size: 0.9rem;
            color: #6b7280;
        }

        .save-status.saving {
            color: #f59e0b;
        }

        .save-status.saved {
            color: #059669;
        }

        .save-status.error {
            color: #dc2626;
        }

        @media (max-width: 768px) {
            .forecast-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }
            
            .import-controls {
                justify-content: center;
            }

            .navigation-bar {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            .save-status {
                margin-left: 0;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="user-info" id="userInfo">
                <span id="userDisplay">Loading...</span>
            </div>
            <h1>ğŸ“ˆ EDI Forecast Management</h1>
            <p>Monthly Production Forecast Planning</p>
        </div>

        <!-- Navigation Bar -->
        <div class="navigation-bar">
            <a href="/dashboard" class="nav-link">ğŸ“Š Dashboard</a>
            <a href="/forecast" class="nav-link active">ğŸ“ˆ Forecast</a>
            <div class="save-status" id="saveStatus">Ready</div>
            <button class="btn btn-logout" onclick="logout()">ğŸšª Logout</button>
        </div>

        <div class="content">
            <div id="messageContainer"></div>
            <div class="loading" id="loadingIndicator">
                <div class="spinner"></div>
                Loading forecast data...
            </div>

            <!-- Forecast Summary -->
            <div class="forecast-summary">
                <h3 style="margin-bottom: 15px; color: #1f2937;">ğŸ“Š Forecast Summary</h3>
                <div class="summary-grid">
                    <div class="summary-item">
                        <div class="summary-number" id="totalForecast">0</div>
                        <div class="summary-label">Total Forecast</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-number" id="nextMonthTotal">0</div>
                        <div class="summary-label">Next Month</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-number" id="changedCells">0</div>
                        <div class="summary-label">Unsaved Changes</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-number" id="lastSaved">-</div>
                        <div class="summary-label">Last Saved</div>
                    </div>
                </div>
            </div>

            <!-- Excel Import Format Notice -->
            <div class="import-notice">
                <h4>ğŸ“‹ Excel Import Format</h4>
                <p>Your Excel file should have this structure:</p>
                <ul>
                    <li><strong>Column A:</strong> Drawing Number (PP4166-4681P003, etc.)</li>
                    <li><strong>Column B:</strong> Product Name (optional)</li>
                    <li><strong>Columns C+:</strong> Month headers (8æœˆ, 9æœˆ, 2025/8, Aug, etc.)</li>
                    <li><strong>Data rows:</strong> Quantity values for each month</li>
                </ul>
                <p>The system will automatically detect month columns and convert them to the correct format.</p>
            </div>

            <!-- Forecast Controls -->
            <div class="forecast-controls">
                <!-- Existing save controls -->
                <button class="btn btn-primary admin-only" id="saveAllBtn" onclick="saveAllForecasts()">
                    ğŸ’¾ Save All Changes
                </button>
                <button class="btn btn-secondary admin-only" id="clearAllBtn" onclick="clearAllForecasts()">
                    ğŸ—‘ï¸ Clear All
                </button>
                
                <!-- Excel Import Controls -->
                <div class="import-controls admin-only">
                    <input type="file" id="forecastFileInput" accept=".xlsx,.xls" style="display: none;">
                    <button class="btn btn-info" id="chooseForecastFileBtn" onclick="chooseForecastFile()">
                        ğŸ“ Choose Excel File
                    </button>
                    <button class="btn btn-warning" id="importForecastBtn" onclick="importForecastExcel()" disabled>
                        ğŸ“¤ Import Forecast Data
                    </button>
                </div>
                
                <!-- Existing other controls -->
                <button class="btn btn-success" id="refreshBtn" onclick="loadForecastData()">
                    ğŸ”„ Refresh Data
                </button>
                <button class="btn btn-secondary" id="debugBtn" onclick="showDebugInfo()">
                    ğŸ” Debug Info
                </button>
                <button class="btn btn-warning" onclick="testForecastTableState()">
                    ğŸ§ª Test Table State
                </button>
                
                <div class="read-only-notice" id="readOnlyNotice">
                    ğŸ‘ï¸ View-Only Mode - Contact admin for edit access
                </div>
            </div>

            <!-- Forecast Table -->
            <div class="data-header">
                <h2>Monthly Production Forecast</h2>
                <span class="record-count" id="recordCount">Loading...</span>
            </div>

            <div class="forecast-table" id="forecastTableContainer">
                <div class="empty-state">
                    <div class="icon">ğŸ“ˆ</div>
                    <h3>Loading Forecast Data</h3>
                    <p>Please wait while we load the forecast information...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script>
        class ForecastManager {
            constructor() {
                this.currentUser = null;
                this.userPermissions = { canEdit: false, canView: true };
                this.forecastData = {};
                this.changedCells = new Set();
                this.months = [];
                this.products = [
                    { drawing: 'PP4166-4681P003', name: 'ï½±ï½¯ï¾Šï¾Ÿï¾Œï¾ï¾šï½°ï¾‘' },
                    { drawing: 'PP4166-4681P004', name: 'ï½±ï½¯ï¾Šï¾Ÿï¾Œï¾ï¾šï½°ï¾‘' },
                    { drawing: 'PP4166-4726P003', name: 'ï¾„ï½¯ï¾Œï¾Ÿï¾Œï¾Ÿï¾šï½°ï¾„' },
                    { drawing: 'PP4166-4726P004', name: 'ï¾„ï½¯ï¾Œï¾Ÿï¾Œï¾Ÿï¾šï½°ï¾„' },
                    { drawing: 'PP4166-4731P002', name: 'ï¾ï¾„ï¾ï¾™ï¾Œï¾šï½°ï¾‘' },
                    { drawing: 'PP4166-7106P001', name: 'ï¾ï¾„ï¾ï¾™ï¾Œï¾šï½°ï¾‘' },
                    { drawing: 'PP4166-7106P003', name: 'ï¾ï¾„ï¾ï¾™ï¾Œï¾šï½°ï¾‘' }
                ];
            }

            // ENHANCED - Generate 12 months starting from current month with consistent formatting
            generateMonths() {
                const months = [];
                const now = new Date();
                
                for (let i = 0; i < 12; i++) {
                    const date = new Date(now.getFullYear(), now.getMonth() + i, 1);
                    const year = date.getFullYear();
                    const month = date.getMonth() + 1;
                    
                    // Ensure consistent MM/01 format
                    const monthKey = `${String(month).padStart(2, '0')}/01`;
                    
                    // Japanese month names
                    const japaneseMonths = ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', 
                                          '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'];
                    
                    // English month names
                    const englishMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                         'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    
                    months.push({
                        key: monthKey,
                        display: japaneseMonths[month - 1],
                        english: englishMonths[month - 1],
                        year: year,
                        month: month,
                        fullDate: `${year}/${String(month).padStart(2, '0')}/01`
                    });
                    
                    console.log(`ğŸ“… Generated month ${i + 1}: key="${monthKey}", display="${japaneseMonths[month - 1]}"`);
                }
                
                this.months = months;
                console.log('ğŸ“… Total months generated:', months.length);
                return months;
            }

            // Load user authentication
            async loadUserInfo() {
                try {
                    const response = await fetch('/api/user-info');
                    if (response.ok) {
                        const userInfo = await response.json();
                        this.currentUser = userInfo;
                        this.userPermissions = userInfo.permissions;
                        
                        this.updateUIForPermissions();
                        this.updateUserDisplay(userInfo);
                        
                        return userInfo;
                    } else {
                        window.location.href = '/';
                        return null;
                    }
                } catch (error) {
                    console.error('Error loading user info:', error);
                    this.showMessage('Failed to load user information', 'error');
                    return null;
                }
            }

            updateUserDisplay(userInfo) {
                const userDisplay = document.getElementById('userDisplay');
                if (userDisplay) {
                    const roleClass = userInfo.role === 'admin' ? 'admin' : 'user';
                    const roleText = userInfo.role === 'admin' ? 'ADMIN' : 'VIEW ONLY';
                    userDisplay.innerHTML = `
                        ${userInfo.username}
                        <span class="user-role ${roleClass}">${roleText}</span>
                    `;
                }
            }

            updateUIForPermissions() {
                const adminElements = document.querySelectorAll('.admin-only');
                const readOnlyNotice = document.getElementById('readOnlyNotice');

                if (!this.userPermissions.canEdit) {
                    adminElements.forEach(element => {
                        element.classList.add('disabled');
                        if (element.tagName === 'BUTTON') {
                            element.disabled = true;
                        }
                    });
                    
                    if (readOnlyNotice) readOnlyNotice.classList.add('show');
                } else {
                    adminElements.forEach(element => {
                        element.classList.remove('disabled');
                        if (element.tagName === 'BUTTON') {
                            element.disabled = false;
                        }
                    });
                    
                    if (readOnlyNotice) readOnlyNotice.classList.remove('show');
                }
            }

            // ENHANCED - Load forecast data with proper type conversion
            async loadForecastData() {
                try {
                    this.showLoading(true);
                    
                    const response = await fetch('/api/forecasts');
                    
                    if (response.status === 401) {
                        this.showMessage('Session expired. Please log in again.', 'error');
                        setTimeout(() => window.location.href = '/', 2000);
                        return;
                    }
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const forecasts = await response.json();
                    console.log('ğŸ“Š Raw forecast data from API:', forecasts);
                    console.log('ğŸ“Š Forecast data count:', forecasts.length);
                    
                    // ENHANCED: Convert array to object with proper type conversion
                    this.forecastData = {};
                    forecasts.forEach((forecast, index) => {
                        const key = `${forecast.drawing_number}-${forecast.month_date}`;
                        // CRITICAL: Ensure quantity is a number
                        const quantity = parseInt(forecast.quantity) || 0;
                        this.forecastData[key] = quantity;
                        console.log(`âœ… Loaded forecast ${index + 1}: ${key} = ${quantity} (type: ${typeof quantity})`);
                    });
                    
                    console.log('ğŸ“Š Processed forecast data object keys:', Object.keys(this.forecastData));
                    console.log('ğŸ“Š Total forecast entries loaded:', Object.keys(this.forecastData).length);
                    console.log('ğŸ“Š Complete forecast data object:', this.forecastData);
                    
                    this.renderForecastTable();
                    this.updateSummary();
                    this.clearChangedCells();
                    
                    // IMMEDIATE VERIFICATION after load
                    setTimeout(() => {
                        this.debugTableState();
                    }, 500);
                    
                } catch (error) {
                    this.showMessage('Failed to load forecast data: ' + error.message, 'error');
                    console.error('Error loading forecast data:', error);
                } finally {
                    this.showLoading(false);
                }
            }

            // ENHANCED - Render forecast table with better debugging
            renderForecastTable() {
                const container = document.getElementById('forecastTableContainer');
                const recordCount = document.getElementById('recordCount');
                
                this.generateMonths();
                
                if (recordCount) {
                    recordCount.textContent = `${this.products.length} products Ã— ${this.months.length} months`;
                }

                console.log('ğŸ¨ Rendering forecast table...');
                console.log('ğŸ“… Generated months:', this.months);
                console.log('ğŸ“Š Current forecast data keys:', Object.keys(this.forecastData));
                console.log('ğŸ“Š Current forecast data:', this.forecastData);

                // DEBUG: Check for any forecast data
                const hasAnyData = Object.keys(this.forecastData).length > 0;
                console.log('ğŸ“Š Has any forecast data:', hasAnyData);

                const tableHTML = `
                    <table>
                        <thead>
                            <tr>
                                <th class="drawing-header">å“ç•ª<br><small>Drawing Number</small></th>
                                <th class="product-header">å“å<br><small>Product Name</small></th>
                                ${this.months.map(month => `
                                    <th class="month-header">
                                        <div class="month-japanese">${month.display}</div>
                                        <div class="month-english">${month.english} ${month.year}</div>
                                    </th>
                                `).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${this.products.map(product => `
                                <tr>
                                    <td class="drawing-cell"><strong>${product.drawing}</strong></td>
                                    <td class="product-cell">${product.name}</td>
                                    ${this.months.map(month => {
                                        const key = `${product.drawing}-${month.key}`;
                                        const value = this.forecastData[key] || 0;
                                        
                                        // ENHANCED DEBUG LOGGING
                                        if (this.forecastData[key]) {
                                            console.log(`ğŸ” Cell Debug:`);
                                            console.log(`   Product: ${product.drawing}`);
                                            console.log(`   Month: ${month.key} (${month.display})`);
                                            console.log(`   Key: ${key}`);
                                            console.log(`   Stored Value: ${this.forecastData[key]}`);
                                            console.log(`   Display Value: ${value}`);
                                            console.log(`   Value Type: ${typeof value}`);
                                        }
                                        
                                        return `
                                            <td>
                                                <input type="number" 
                                                       class="forecast-input" 
                                                       value="${value > 0 ? value : ''}"
                                                       data-drawing="${product.drawing}"
                                                       data-month="${month.key}"
                                                       data-key="${key}"
                                                       placeholder="0"
                                                       min="0"
                                                       ${!this.userPermissions.canEdit ? 'disabled' : ''}
                                                       onchange="forecastManager.onCellChange(this)"
                                                       onblur="forecastManager.onCellBlur(this)">
                                            </td>
                                        `;
                                    }).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;

                container.innerHTML = tableHTML;
                console.log('âœ… Forecast table rendered');
                
                // IMMEDIATE VERIFICATION: Check if any input has values
                setTimeout(() => {
                    const inputs = document.querySelectorAll('.forecast-input');
                    let filledInputs = 0;
                    inputs.forEach(input => {
                        if (input.value && input.value !== '0' && input.value !== '') {
                            filledInputs++;
                            console.log(`âœ… Found filled input: ${input.dataset.key} = ${input.value}`);
                        }
                    });
                    console.log(`ğŸ“Š Total filled inputs after render: ${filledInputs} / ${inputs.length}`);
                    
                    if (filledInputs === 0 && Object.keys(this.forecastData).length > 0) {
                        console.log('âŒ ERROR: Have forecast data but no inputs are filled!');
                        console.log('ğŸ“Š Forecast data keys:', Object.keys(this.forecastData));
                        console.log('ğŸ“Š Month keys generated:', this.months.map(m => m.key));
                    }
                }, 100);
            }

            // Handle cell value changes
            onCellChange(input) {
                const key = input.dataset.key;
                const value = parseInt(input.value) || 0;
                
                // Mark as changed
                input.classList.add('changed');
                this.changedCells.add(key);
                
                // Update local data
                this.forecastData[key] = value;
                
                this.updateSummary();
                this.updateSaveStatus('unsaved', 'Unsaved changes');
            }

            onCellBlur(input) {
                // Auto-save individual cell if user has permission and auto-save is enabled
                if (this.userPermissions.canEdit) {
                    // Optional: implement auto-save for individual cells
                }
            }

            // ğŸ”§ FIXED - Save all forecast changes with proper key parsing
            async saveAllForecasts() {
                if (!this.userPermissions.canEdit) {
                    this.showMessage('You do not have permission to save changes', 'error');
                    return;
                }

                if (this.changedCells.size === 0) {
                    this.showMessage('No changes to save', 'warning');
                    return;
                }

                try {
                    this.updateSaveStatus('saving', 'Saving...');
                    this.showLoading(true);
                    
                    const forecasts = [];
                    this.changedCells.forEach(key => {
                        console.log(`ğŸ’¾ Processing changed cell: ${key}`);
                        
                        // FIXED: Proper parsing using lastIndexOf to handle multiple dashes
                        const lastDashIndex = key.lastIndexOf('-');
                        
                        if (lastDashIndex === -1) {
                            console.error(`âŒ Invalid key format: ${key}`);
                            return;
                        }
                        
                        const drawingNumber = key.substring(0, lastDashIndex);    // "PP4166-4681P003"
                        const monthDate = key.substring(lastDashIndex + 1);       // "08/01"
                        
                        console.log(`ğŸ’¾ Parsed key "${key}":`);
                        console.log(`   Drawing: "${drawingNumber}"`);
                        console.log(`   Month: "${monthDate}"`);
                        console.log(`   Quantity: ${this.forecastData[key]}`);
                        
                        // Use correct field names that match backend expectation
                        forecasts.push({
                            drawing_number: drawingNumber,   // Match backend field name
                            month_date: monthDate,           // Match backend field name
                            quantity: this.forecastData[key] || 0
                        });
                    });

                    console.log('ğŸ’¾ Forecast data to save:', forecasts);

                    const response = await fetch('/api/forecasts/batch', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ forecasts })
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.showMessage(`Saved ${result.saved} forecast entries successfully`, 'success');
                        this.clearChangedCells();
                        this.updateSaveStatus('saved', 'All changes saved');
                        this.updateSummary();
                        
                        // IMMEDIATE DEBUG: Check what was actually saved
                        console.log('ğŸ” DEBUG: Immediately after save success:');
                        console.log('ğŸ“Š Current forecastData:', this.forecastData);
                        
                        // Force refresh from server to verify
                        setTimeout(async () => {
                            console.log('ğŸ”„ Verifying save by reloading from server...');
                            await this.loadForecastData();
                        }, 1000);
                    } else {
                        this.showMessage(result.error || 'Failed to save forecasts', 'error');
                        this.updateSaveStatus('error', 'Save failed');
                    }
                } catch (error) {
                    this.showMessage('Failed to save forecasts: ' + error.message, 'error');
                    this.updateSaveStatus('error', 'Save failed');
                } finally {
                    this.showLoading(false);
                }
            }

            // Clear all forecast data
            async clearAllForecasts() {
                if (!this.userPermissions.canEdit) {
                    this.showMessage('You do not have permission to clear data', 'error');
                    return;
                }

                if (!confirm('Are you sure you want to clear all forecast data? This action cannot be undone.')) {
                    return;
                }

                try {
                    this.showLoading(true);
                    
                    // Clear all inputs
                    const inputs = document.querySelectorAll('.forecast-input');
                    inputs.forEach(input => {
                        input.value = '';
                        input.classList.add('changed');
                        const key = input.dataset.key;
                        this.changedCells.add(key);
                        this.forecastData[key] = 0;
                    });

                    this.updateSummary();
                    this.updateSaveStatus('unsaved', 'Ready to save cleared data');
                    this.showMessage('All forecast data cleared. Click "Save All Changes" to confirm.', 'warning');
                    
                } finally {
                    this.showLoading(false);
                }
            }

            // Clear changed cells tracking
            clearChangedCells() {
                this.changedCells.clear();
                
                // Remove changed styling from inputs
                const inputs = document.querySelectorAll('.forecast-input.changed');
                inputs.forEach(input => {
                    input.classList.remove('changed');
                });
            }

            // Update summary statistics
            updateSummary() {
                const totalForecast = Object.values(this.forecastData).reduce((sum, val) => sum + (val || 0), 0);
                
                // Calculate next month total
                const nextMonth = this.months[1]; // Next month after current
                let nextMonthTotal = 0;
                if (nextMonth) {
                    this.products.forEach(product => {
                        const key = `${product.drawing}-${nextMonth.key}`;
                        nextMonthTotal += this.forecastData[key] || 0;
                    });
                }

                // Update UI
                document.getElementById('totalForecast').textContent = totalForecast.toLocaleString();
                document.getElementById('nextMonthTotal').textContent = nextMonthTotal.toLocaleString();
                document.getElementById('changedCells').textContent = this.changedCells.size;
                
                // Update last saved time
                if (this.changedCells.size === 0) {
                    const now = new Date();
                    document.getElementById('lastSaved').textContent = now.toLocaleTimeString();
                }
            }

            // Update save status
            updateSaveStatus(status, message) {
                const saveStatus = document.getElementById('saveStatus');
                if (saveStatus) {
                    saveStatus.textContent = message;
                    saveStatus.className = 'save-status ' + status;
                }
            }

            // Utility methods
            showLoading(show) {
                const loading = document.getElementById('loadingIndicator');
                if (loading) {
                    loading.style.display = show ? 'block' : 'none';
                }
            }

            showMessage(message, type) {
                const container = document.getElementById('messageContainer');
                if (!container) return;

                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                messageDiv.textContent = message;
                
                container.appendChild(messageDiv);
                
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.parentNode.removeChild(messageDiv);
                    }
                }, 5000);
            }

            async logout() {
                try {
                    await fetch('/api/logout', { method: 'POST' });
                    window.location.href = '/';
                } catch (error) {
                    console.error('Logout error:', error);
                    window.location.href = '/';
                }
            }

            // ENHANCED Debug function to check data consistency
            async showDebugInfo() {
                try {
                    const response = await fetch('/api/debug/forecasts');
                    if (response.ok) {
                        const debugData = await response.json();
                        console.log('ğŸ” DEBUG: Raw database data:', debugData);
                        
                        alert(`Debug Info:
ğŸ“Š Data source: ${debugData.source}
ğŸ“Š Total records: ${debugData.count}
ğŸ“Š Sample data: ${JSON.stringify(debugData.data.slice(0, 3), null, 2)}

ğŸ“Š Local forecast data keys: ${Object.keys(this.forecastData).length}
ğŸ“Š Generated months: ${this.months.length}

Check console for detailed logs.`);
                    } else {
                        alert('Failed to fetch debug info');
                    }
                } catch (error) {
                    console.error('Debug error:', error);
                    alert('Debug error: ' + error.message);
                }
            }

            // ENHANCED Debug helper function - Table state verification
            debugTableState() {
                console.log('ğŸ” TABLE STATE DEBUG:');
                console.log('ğŸ“Š Forecast data object:', this.forecastData);
                console.log('ğŸ“Š Generated months:', this.months);
                
                // Check each product-month combination
                this.products.forEach(product => {
                    console.log(`\nğŸ” Product: ${product.drawing}`);
                    this.months.forEach((month, index) => {
                        const key = `${product.drawing}-${month.key}`;
                        const storedValue = this.forecastData[key];
                        const inputElement = document.querySelector(`[data-key="${key}"]`);
                        const inputValue = inputElement ? inputElement.value : 'NOT_FOUND';
                        
                        if (storedValue || inputValue) {
                            console.log(`   Month ${index + 1} (${month.key}):`);
                            console.log(`     Key: ${key}`);
                            console.log(`     Stored: ${storedValue} (${typeof storedValue})`);
                            console.log(`     Input: ${inputValue}`);
                            console.log(`     Element exists: ${!!inputElement}`);
                        }
                    });
                });
                
                // Summary
                const totalStoredEntries = Object.keys(this.forecastData).length;
                const filledInputs = document.querySelectorAll('.forecast-input').length;
                const nonEmptyInputs = Array.from(document.querySelectorAll('.forecast-input')).filter(input => input.value && input.value !== '0').length;
                
                console.log(`\nğŸ“Š SUMMARY:`);
                console.log(`   Stored entries: ${totalStoredEntries}`);
                console.log(`   Total inputs: ${filledInputs}`);
                console.log(`   Non-empty inputs: ${nonEmptyInputs}`);
            }

            // Initialize the forecast manager
            async initialize() {
                try {
                    console.log('ğŸš€ Initializing Forecast Manager...');
                    
                    await this.loadUserInfo();
                    await this.loadForecastData();
                    
                    // Auto-refresh every 5 minutes
                    setInterval(() => {
                        if (this.changedCells.size === 0) {
                            this.loadForecastData();
                        }
                    }, 300000);
                    
                    console.log('âœ… Forecast Manager initialized successfully');
                } catch (error) {
                    console.error('âŒ Failed to initialize forecast manager:', error);
                    this.showMessage('Failed to initialize forecast manager', 'error');
                }
            }
        }

        // Create global instance
        const forecastManager = new ForecastManager();

        // Handle forecast file selection
        function chooseForecastFile() {
            const fileInput = document.getElementById('forecastFileInput');
            if (fileInput) {
                fileInput.click();
            }
        }

        // Import forecast data from Excel
        async function importForecastExcel() {
            if (!forecastManager.userPermissions.canEdit) {
                forecastManager.showMessage('You do not have permission to import data', 'error');
                return;
            }

            const fileInput = document.getElementById('forecastFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                forecastManager.showMessage('Please select an Excel file first', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('forecastFile', file);

            try {
                forecastManager.showLoading(true);
                forecastManager.showMessage('Importing forecast data from Excel...', 'info');
                
                const response = await fetch('/api/import-forecast', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    forecastManager.showMessage(result.message, 'success');
                    
                    // Show import details
                    if (result.details) {
                        console.log('ğŸ“Š Import details:', result.details);
                        const detailsMsg = `Import completed: ${result.details.saved} forecasts saved from ${result.details.rowsProcessed} rows`;
                        forecastManager.showMessage(detailsMsg, 'info');
                    }
                    
                    // Reload forecast data
                    await forecastManager.loadForecastData();
                    
                    // Reset file input
                    fileInput.value = '';
                    const importBtn = document.getElementById('importForecastBtn');
                    if (importBtn) {
                        importBtn.disabled = true;
                        importBtn.textContent = 'ğŸ“¤ Import Forecast Data';
                    }
                } else {
                    forecastManager.showMessage(result.error || 'Import failed', 'error');
                    if (result.details) {
                        console.error('âŒ Import error details:', result.details);
                    }
                }
            } catch (error) {
                if (error.message.includes('403')) {
                    forecastManager.showMessage('You do not have permission to import data', 'error');
                } else {
                    forecastManager.showMessage('Import failed: ' + error.message, 'error');
                }
                console.error('âŒ Import error:', error);
            } finally {
                forecastManager.showLoading(false);
            }
        }

        // Global functions
        function saveAllForecasts() {
            forecastManager.saveAllForecasts();
        }

        function clearAllForecasts() {
            forecastManager.clearAllForecasts();
        }

        function loadForecastData() {
            forecastManager.loadForecastData();
        }

        function logout() {
            forecastManager.logout();
        }

        function showDebugInfo() {
            forecastManager.showDebugInfo();
        }

        // ENHANCED Debug testing functions
        window.testForecastDebug = function() {
            forecastManager.debugForecastData();
        };

        window.testSessionDebug = async function() {
            try {
                const response = await fetch('/api/user-info');
                const data = await response.json();
                console.log('ğŸ” Session debug - User info:', data);
                return data;
            } catch (error) {
                console.log('âŒ Session debug failed:', error);
                return null;
            }
        };

        window.testForecastTableState = function() {
            if (forecastManager) {
                forecastManager.debugTableState();
            } else {
                console.log('âŒ Forecast manager not found');
            }
        };

        window.testForceRefresh = async function() {
            if (forecastManager) {
                console.log('ğŸ”„ Forcing forecast data refresh...');
                await forecastManager.loadForecastData();
                console.log('âœ… Refresh complete');
            } else {
                console.log('âŒ Forecast manager not found');
            }
        };

        // Add file input change handler
        document.addEventListener('DOMContentLoaded', function() {
            forecastManager.initialize();
            
            const forecastFileInput = document.getElementById('forecastFileInput');
            const importForecastBtn = document.getElementById('importForecastBtn');
            
            if (forecastFileInput && importForecastBtn) {
                forecastFileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    
                    if (file && forecastManager.userPermissions.canEdit) {
                        importForecastBtn.disabled = false;
                        importForecastBtn.textContent = `ğŸ“¤ Import ${file.name}`;
                        forecastManager.showMessage(`Excel file selected: ${file.name}`, 'success');
                    } else {
                        importForecastBtn.disabled = true;
                        importForecastBtn.textContent = 'ğŸ“¤ Import Forecast Data';
                    }
                });
            }
        });
    </script>
</body>
</html>